package joseUtils

import (
	"encoding/base64"
	"encoding/json"
	"strings"
)

// DeserializeJWE deserializes the given serialized JWE into a JWEncryptionGo object.
//	- ProtectedHeaders as map[string]interface{} (JSON)
//	- OrigProtectedHders as Base64Url encoded string
//	- UnprotectedHeaders as map[string]interface{} (JSON)
//	- Recipients is an array of recipients which contains the encrypted CEK for each recipient (only one recipient is allowed in OpenID).
//	- AAD: Additional Authentication Data encoded as Base64Url string.
//	- IV (Initialization Vector): nonce / random bytes encoded as Base64Url string.
//	- Ciphertext: the stringified and encrypted data bytes, encoded as Base64Url string.
//	- Tag: bytes generated by the cipher algorithm, encoded as Base64Url string.
func DeserializeJWE(serializedJWE string) (*JWEncryptionGo, error) {
	if strings.HasPrefix(serializedJWE, "{") {
		return DeserializeJsonJWE(serializedJWE)
	}

	return DeserializeCompactJWE(serializedJWE)
}

// DeserializeJsonJWE gets the parts of a JSON JWE (no compact serialization):
//	- ProtectedHeaders as map[string]interface{} (JSON)
//	- OrigProtectedHders as Base64Url encoded string
//	- UnprotectedHeaders as map[string]interface{} (JSON)
//	- Recipients is an array of recipients which contains the encrypted CEK for each recipient (only one recipient is allowed in OpenID).
//	- AAD: Additional Authentication Data encoded as Base64Url string.
//	- IV (Initialization Vector): nonce / random bytes encoded as Base64Url string.
//	- Ciphertext: the stringified and encrypted data bytes, encoded as Base64Url string.
//	- Tag: bytes generated by the cipher algorithm, encoded as Base64Url string.
func DeserializeJsonJWE(serializedJWE string) (*JWEncryptionGo, error) {
	rawJWE := JWEncryptionRawJSON{}

	err := json.Unmarshal([]byte(serializedJWE), &rawJWE)
	if err != nil {
		return nil, err
	}

	return DeserializeFromRawJWE(&rawJWE)
}

// DeserializeCompactJWE gets the parts of a compact JWE:
//	- ProtectedHeaders as map[string]interface{} (JSON)
//	- OrigProtectedHders as Base64Url encoded string
//	- UnprotectedHeaders as map[string]interface{} (JSON)
//	- Recipients is an array of recipients which contains the encrypted CEK for each recipient (only one recipient is allowed in OpenID).
//	- AAD: Additional Authentication Data encoded as Base64Url string.
//	- IV (Initialization Vector): nonce / random bytes encoded as Base64Url string.
//	- Ciphertext: the stringified and encrypted data bytes, encoded as Base64Url string.
//	- Tag: bytes generated by the cipher algorithm, encoded as Base64Url string.
func DeserializeCompactJWE(serializedJWE string) (*JWEncryptionGo, error) {
	parts := strings.Split(serializedJWE, ".")
	if len(parts) != compactJWERequiredNumOfParts {
		return nil, errWrongNumberOfCompactJWEParts
	}

	rawJWE := JWEncryptionRawJSON{
		B64ProtectedHeaders:      parts[0],
		B64SingleRecipientEncKey: parts[1],
		B64IV:                    parts[2],
		B64Ciphertext:            parts[3],
		B64Tag:                   parts[4],
	}

	return DeserializeFromRawJWE(&rawJWE)
}

func DeserializeFromRawJWE(rawJWE *JWEncryptionRawJSON) (*JWEncryptionGo, error) {
	protectedHeaders, unprotectedHeaders, err := DeserializeAndDecodeHeadersJWE(rawJWE)
	if err != nil {
		return nil, err
	}

	recipients, err := DeserializeRecipientsJWE(rawJWE)
	if err != nil {
		return nil, err
	}

	aad, err := base64.RawURLEncoding.DecodeString(rawJWE.B64AAD)
	if err != nil {
		return nil, err
	}

	iv, err := base64.RawURLEncoding.DecodeString(rawJWE.B64IV)
	if err != nil {
		return nil, err
	}

	ciphertext, err := base64.RawURLEncoding.DecodeString(rawJWE.B64Ciphertext)
	if err != nil {
		return nil, err
	}

	tag, err := base64.RawURLEncoding.DecodeString(rawJWE.B64Tag)
	if err != nil {
		return nil, err
	}

	deserializedJWE := JWEncryptionGo{
		ProtectedHeaders:   *protectedHeaders,
		OrigProtectedHders: rawJWE.B64ProtectedHeaders,
		UnprotectedHeaders: *unprotectedHeaders,
		Recipients:         recipients,
		AAD:                string(aad),
		IV:                 string(iv),
		Ciphertext:         string(ciphertext),
		Tag:                string(tag),
	}

	return &deserializedJWE, nil
}

func DeserializeAndDecodeHeadersJWE(rawJWE *JWEncryptionRawJSON) (protectedHeaders *map[string]interface{}, unprotectedHeaders *map[string]interface{}, err error) {
	protectedHeadersBytes, err := base64.RawURLEncoding.DecodeString(rawJWE.B64ProtectedHeaders)
	if err != nil {
		return nil, nil, err
	}

	var protectedHeadersJSON map[string]interface{}

	err = json.Unmarshal(protectedHeadersBytes, &protectedHeadersJSON)
	if err != nil {
		return nil, nil, err
	}

	var unprotectedHeadersJSON map[string]interface{}

	if rawJWE.UnprotectedHeaders != nil {
		err = json.Unmarshal(rawJWE.UnprotectedHeaders, &unprotectedHeadersJSON)
		if err != nil {
			return nil, nil, err
		}
	}

	return &protectedHeadersJSON, &unprotectedHeadersJSON, nil
}

func ParseDeserializeRecipientsJWE(rawJWE *JWEncryptionRawJSON) ([]*RecipientJWE, error) {
	if rawJWE.Recipients != nil {
		var recipients []*RecipientJWE

		err := json.Unmarshal(rawJWE.Recipients, &recipients)
		if err != nil {
			return nil, err
		}

		return recipients, nil
	}

	// If there is no recipients field, then we must be deserializing JWE with the flattened syntax as defined in
	// https://tools.ietf.org/html/rfc7516#section-7.2.2.
	recipient := &RecipientJWE{EncryptedKey: rawJWE.B64SingleRecipientEncKey}

	if rawJWE.SingleRecipientHeader != nil {
		err := json.Unmarshal(rawJWE.SingleRecipientHeader, &recipient.Header)
		if err != nil {
			return nil, err
		}
	}

	return []*RecipientJWE{recipient}, nil
}

func DeserializeRecipientsJWE(rawJWE *JWEncryptionRawJSON) ([]*RecipientJWE, error) {
	recipients, err := ParseDeserializeRecipientsJWE(rawJWE)
	if err != nil {
		return nil, err
	}

	for _, recipient := range recipients {
		decodedEncKey, err := base64.RawURLEncoding.DecodeString(recipient.EncryptedKey)
		if err != nil {
			return nil, err
		}

		recipient.EncryptedKey = string(decodedEncKey)
	}

	return recipients, nil
}
